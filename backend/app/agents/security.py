from typing import List, Dict, Any
from backend.app.schemas.ai import FraudFlag

class SecurityAgent:
    """
    Security & Verification Tool:
    - Fingerprints invoices (Duplicate Check)
    - Verifies Vendor Trust (Allowlist/Blocklist)
    """

    def __init__(self, db_session = None):
        self.db = db_session  # Mock for now

    def fingerprint(self, vendor: str, inv_id: str, amount: float) -> str:
        """
        Create deterministic hash (SHA-256) to detect duplicates.
        Logic: f"{vendor.lower()}-{inv_id.strip()}-{amount}"
        """
        import hashlib
        raw = f"{vendor.lower().strip()}-{inv_id.strip()}-{amount}"
        return hashlib.sha256(raw.encode()).hexdigest()

    def check_duplicate(self, fingerprint: str) -> bool:
        # Mock DB Lookup: In real app, query `invoices` table
        # SELECT EXISTS(SELECT 1 FROM invoices WHERE invoice_hash = :fingerprint)
        
        # Simulating that "INV-8842" (from dashboard) is a duplicate
        if "8842" in fingerprint: 
            return True
        return False

    def verify_vendor(self, vendor_name: str) -> Dict[str, Any]:
        """
        Check if vendor is Trusted, New, or Flagged.
        Result: { status: 'TRUSTED' | 'NEW' | 'FLAGGED', score: 0-100, data: {...} }
        """
        from backend.app.services.erp_mock import erp_system
        erp_result = erp_system.validate_vendor(vendor_name)
        
        if erp_result.get('exists'):
            v_data = erp_result.get('data', {})
            risk = v_data.get('risk_score', 50)
            if risk >= 80:
                return {"status": "FLAGGED", "score": 100 - risk, "data": v_data}
            return {"status": "TRUSTED", "score": 100 - risk, "data": v_data}
        
        return {"status": "NEW", "score": 40, "data": None}

    def verify_gstin(self, gstin: str) -> Dict[str, Any]:
        """
        Validates GSTIN checksum and format.
        Real implementation would call GSTN API.
        """
        if not gstin:
            return {"valid": False, "message": "No GSTIN found"}
            
        # 1. Format Check (Regex is already done, double check length)
        if len(gstin) != 15:
            return {"valid": False, "message": "Invalid GSTIN Length"}
            
        # 2. Checksum Simulation (The 15th char is check digit)
        # Mock Logic: If last char is '0', treat as invalid for demo
        if gstin[-1] == '0':
             return {"valid": False, "message": "Invalid Checksum (Mock)"}
             
        return {"valid": True, "message": "GSTIN Structure Valid"}

    def analyze_digital_footprint(self, file_metadata: Dict) -> Dict[str, Any]:
        """
        Digital Forensics:
        - Detects if PDF was created by 'Adobe Photoshop' (Fake)
        - Checks for recent modification dates
        - Verifies PDF structure integrity
        """
        producer = file_metadata.get('producer', '').lower()
        creator = file_metadata.get('creator', '').lower()
        
        flags = []
        score = 100
        
        # Red Flag: Created with Image Editing Software
        if 'photoshop' in producer or 'gimp' in producer:
            flags.append("Document created with Image Editor (High Risk of Forgery)")
            score -= 50
            
        # Red Flag: Generic PDF writers often used in mass phishing
        if 'ilovepdf' in producer or 'smallpdf' in producer:
            flags.append("Processed via public PDF tools (Potential Data Leak)")
            score -= 10
            
        # Fake Email Detection (Simulation)
        # If the invoice claims to be from "Amazon" but metadata says "PHP Mailer"
        if 'php' in creator or 'python' in creator:
            flags.append("Generated by script, not standard accounting software")
            score -= 20
            
        return {
            "score": score,
            "is_suspicious": score < 70,
            "flags": flags
        }

    def verify_email_domain(self, vendor_name: str, email_domain: str) -> bool:
        """
        Direct Email Access Logic (Simulated):
        Checks if the invoice source email matches the vendor's official domain.
        """
        # Mock Knowledge Base
        domain_map = {
            "amazon": "amazon.com",
            "google": "google.com",
            "microsoft": "microsoft.com",
            "acme": "acme.corp"
        }
        
        vendor_key = next((k for k in domain_map if k in vendor_name.lower()), None)
        if vendor_key:
            expected = domain_map[vendor_key]
            if email_domain != expected:
                return False # Mismatch (e.g. Amazon invoice from gmail.com)
        
        return True # Default to True if we don't know the vendor domain

    def verify_bank_details(self, vendor_data: Dict, extracted_data: Dict) -> Dict[str, Any]:
        """
        Critical 3-Way Match Step:
        Compares extracted Bank Account/IFSC/IBAN against Vendor Master Data.
        """
        # If we don't know the vendor, we can't verify their bank (High Risk for New Vendor)
        if not vendor_data:
             return {"match": False, "reason": "Vendor not found in Master Data"}
             
        master_acc = vendor_data.get('bank_account')
        master_ifsc = vendor_data.get('ifsc')
        
        extracted_acc = extracted_data.get('account_number')
        extracted_iban = extracted_data.get('iban')
        extracted_ifsc = extracted_data.get('ifsc')
        
        # 1. Exact Account Match
        if extracted_acc and master_acc:
            if extracted_acc != master_acc:
                return {"match": False, "reason": f"Account mismatch: Invoice has {extracted_acc}, System has {master_acc}"}
        
        # 2. IFSC Match
        if extracted_ifsc and master_ifsc:
            if extracted_ifsc != master_ifsc:
                return {"match": False, "reason": f"IFSC mismatch: Invoice has {extracted_ifsc}, System has {master_ifsc}"}
                
        # 3. Safe if no conflicting data found (or no data extracted)
        # In strict mode, we might require at least one match, but for now we assume innocent until proven guilty
        return {"match": True, "reason": "Bank Details Verified"}
